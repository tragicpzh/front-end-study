# web调试工具
## 浏览器调试
    IE、chorme、firefox-firebug
## 自动化测试
    selenuim、selenuim IDE、PhantomJS
## 接口化测试
    fiddler、postman、soapUI
## 性能测试
    JMeter、LoadRunner
# 计算机网络
## HTTP
### 简介
    超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。
### 工作原理
    1.http协议采用请求/响应模型，过程为
        客户端连接到WEB服务器，即建立TCP连接
        客户端发送HTTP请求
        服务器接受请求并返回HTTP响应
        释放TCP连接
        客户端浏览器解析HTML内容
    2.无状态保存，无状态协议
        HTTP自身不对请求和响应之前的通信状态进行保存
        为了解决无状态导致的业务处理问题，引入了cookie技术
    3.无连接
        每次连接处理一个请求，收到客户端的应答后就断开连接
### 请求方法
    GET POST HEAD PUT DELETE OPTIONS CONNECT TRACE
### HTTP状态码
        1xx消息——请求已被服务器接收，继续处理
        2xx成功——请求已成功被服务器接收、理解、并接受
        3xx重定向——需要后续操作才能完成这一请求
        4xx请求错误——请求含有词法错误或者无法被执行
        5xx服务器错误——服务器在处理某个正确请求时发生错误
### 常见的状态码
        200 请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。
        202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。
        300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。
        301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
        400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。
        404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。
        500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。
        503 由于临时的服务器维护或者过载，服务器当前无法处理请求。
## HTTPS
### 简介
    HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
### 工作过程
    （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
　　（5）Web服务器利用自己的私钥解密出会话密钥。
　　（6）Web服务器利用会话密钥加密与客户端之间的通信。
### 实现原理
    1.对称加密
        加密和解密使用同一个密钥
    2.非对称加密
        加密和解密不使用同一个密钥，称为公钥和私钥
    3.哈希算法
        用于验证数据是否被篡改
### 数字证书
    数字证书是由受信任的数字证书颁发机构CA,包含了一个密钥对（公钥和密钥）
### 加密方式
    客户端使用对称加密的密钥对传输数据进行加密，使用非对称加密的公钥进行解密
    客户端和服务端建立 SSL 握手：客户端通过 CA 证书来确认服务端的身份；互相传递三个随机数，之后通过这随机数来生成一个密钥；互相确认密钥，然后握手结束；数据通讯开始，都使用同一个对话密钥来加解密；
    我们可以发现，在 HTTPS 加密原理的过程中把对称加密和非对称加密都利用了起来。即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处
### 与http的差别
    1.http是明文传输，是超文本传输协议,端口为80
    2.https是具有安全性的ssl加密传输协议，ssl+http，端口为443
## TCP
### 简介
    TCP提供一种面向连接的可靠的字节流服务
### 建立过程
    TCP是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接，建立一条连接有以下过程。 
    1、请求端（客户端）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序列号（ISN），这个SYN为报文段1. 
    2、服务器发回包含服务器的初始序列号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个字符。 
    3、客户必须将明确序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3） 
    4、这三个报文段完成连接的建立，这个过程成为三次握手。
### 终止过程
    1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 
    2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 
    客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 
    3、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。 
    客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 
    4、服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 
### 可靠传输
    TCP提供了可靠的传输服务，这是通过下列方式提供的：
    分块发送：应用数据被分割成TCP认为最适合发送的数据块。由TCP传递给IP的信息单位称为报文段或段（segment）
    定时确认重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
    当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒
    数据校验：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
    正确排序：由于IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
    重复丢弃：IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
    流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。
### tcp和udp的差别
    tcp:可靠、稳定、慢、效率低、占用系统资源高，有连接
    udp:快、安全、无状态、传递快、不可靠、不稳定，无连接
# 线程和进程的区别
    线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。
    根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
    资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
    包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
    内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
    影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
    执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
# 数据库三大范式
    第一范式(确保每列保持原子性)
    第二范式(确保表中的每列都和主键相关)
    第三范式(确保每列都和主键列直接相关,而不是间接相关)
# 浏览器运行时的进程
    浏览器主进程 第三方插件进程 GPU进程 浏览器渲染进程（浏览器内核）
# 锁
## 作用
    为方法、代码块加锁，使得同一时刻只有一个线程对该代码块进行执行操作，其他线程只能执行非加锁代码块
## 死锁
### 原因
    1.竞争资源
    2.进程推进顺序不当
### 必要条件
    1.互斥，资源在某一时刻只能分配给一个线程使用
    2.持有，当资源导致线程堵塞时，资源占用着不但不释放资源，反而可以继续请求资源
    3.不可剥夺，互斥资源不能被剥夺，只能由占有者释放
    4.环形等待，若干线程以不同次序获取互斥资源，形成环形等待（你等我释放，我等你释放）
## 锁的实现
    1.条件变量 2.信号量 3.互斥量（锁）
    条件变量与互斥量一起使用
    互斥量负责线程互斥，条件变量负责线程之间同步
    信号量实现线程同步和进程同步
## 生产者-消费者
### 背景
    既是互斥，又是同步
    互斥：对缓冲区的访问
    同步：两者互相协作，有生产才能消费
## 解决方法（伪代码）
    semaphore mutex=1; //临界区互斥信号量
    semaphore empty=n;  //空闲缓冲区
    semaphore full=0;  //缓冲区初始化为空
    producer () { //生产者进程
        while(1){
            produce an item in nextp;  //生产数据
            P(empty);  //获取空缓冲区单元
            P(mutex);  //进入临界区.
            add nextp to buffer;  //将数据放入缓冲区
            V(mutex);  //离开临界区,释放互斥信号量
            V(full);  //满缓冲区数加1
        }
    }

    consumer () {  //消费者进程
        while(1){
            P(full);  //获取满缓冲区单元
            P(mutex);  // 进入临界区
            remove an item from buffer;  //从缓冲区中取出数据
            V (mutex);  //离开临界区，释放互斥信号量
            V (empty) ;  //空缓冲区数加1
            consume the item;  //消费数据
        }
    }